<!DOCTYPE html><!--57A_BHLQooNDOH8pzkRaP--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/desk-on-demand/_next/static/media/c50f3c9c65fbdb75-s.p.cb017eca.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="images/duckling_follow.jpg"/><link rel="preload" as="image" href="images/system_diagram.png"/><link rel="preload" as="image" href="images/early_software_diagram.png"/><link rel="preload" as="image" href="images/IMG_2746.JPEG"/><link rel="preload" as="image" href="images/TrashbotV1_CAD.png"/><link rel="preload" as="image" href="images/TrashbotV2_full_CAD.png"/><link rel="preload" as="image" href="images/TrashbotV2_top_view_real.png"/><link rel="preload" as="image" href="images/Chair_sketches1.png"/><link rel="preload" as="image" href="images/Chair_sketches2.png"/><link rel="preload" as="image" href="images/Chair_sketch_final.png"/><link rel="stylesheet" href="/desk-on-demand/_next/static/chunks/9e7b770538ff6f2d.css" data-precedence="next"/><link rel="stylesheet" href="/desk-on-demand/_next/static/chunks/879e74ca08e01695.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/desk-on-demand/_next/static/chunks/5f8f53e7772f4262.js"/><script src="/desk-on-demand/_next/static/chunks/a0e9039376638b5f.js" async=""></script><script src="/desk-on-demand/_next/static/chunks/b5e36c8a3122cd19.js" async=""></script><script src="/desk-on-demand/_next/static/chunks/turbopack-5761cb564367e007.js" async=""></script><script src="/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js" async=""></script><script src="/desk-on-demand/_next/static/chunks/3ed5c16b8b4912f1.js" async=""></script><link rel="preload" as="image" href="images/Chair_CAD.png"/><link rel="preload" as="image" href="images/78542965809__6B6E25D3-66FC-4EFB-A777-5FE0BB3E6129.JPEG"/><link rel="preload" as="image" href="images/IMG_2819.JPEG"/><link rel="preload" as="image" href="images/IMG_2860.JPEG"/><link rel="preload" as="image" href="images/IMG_2870.JPEG"/><link rel="preload" as="image" href="images/IMG_2868.JPEG"/><link rel="preload" as="image" href="images/4614C96E-88C2-4276-AD32-46FA83D43B99.JPEG"/><link rel="preload" as="image" href="images/energy_flow.png"/><link rel="preload" as="image" href="images/electrical_diagram.png"/><link rel="preload" as="image" href="images/uml.png"/><meta name="next-size-adjust" content=""/><title>Desk On Demand</title><script src="/desk-on-demand/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="inconsolata_db231763-module__KRi-XW__className"><div hidden=""><!--$--><!--/$--></div><header class="navbar"><a href="#" class="navbar-icon"><svg data-prefix="fas" data-icon="chair" class="svg-inline--fa fa-chair " role="img" viewBox="0 0 448 512" aria-hidden="true"><path fill="currentColor" d="M152 256l0-181.8c-24.5 20.5-40 51.4-40 85.8l0 96 40 0zm48 0l48 0 0-205.4c-7.7-1.7-15.8-2.6-24-2.6s-16.3 .9-24 2.6L200 256zM296 74.2l0 181.8 40 0 0-96c0-34.4-15.5-65.2-40-85.8zM32 256l32 0 0-96C64 71.6 135.6 0 224 0S384 71.6 384 160l0 96 32 0c17.7 0 32 14.3 32 32l0 64c0 17.7-14.3 32-32 32l0 96c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-96-256 0 0 96c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-96c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32z"></path></svg></a><nav class="navbar-links"><a href="#overview">Overview</a><a href="#mechanical">Mechanical</a><a href="#electrical">Electrical</a><a href="#software">Software</a><a href="#project-management">Project Management</a></nav></header><main class="container"><section class="hero"><div class="hero-content"><h1>Desk On Demand</h1></div></section><section id="overview" class="card"><h2>Overview</h2><p>By Ben Ricket, Nathaniel Banse, Alyssa Aranda, Lukas Littlejohn, and Julian Shah</p>
<p>We have built an autonomous robotic chair and trashcan, both of which are eager to follow people (or each other) and patiently wait behind them.
This design solves the age-old problem of people being too lazy to walk to a chair, wishing one were immediately behind them instead.
This target group of people too lazy to walk to a chair provides another probelm we have to address: Litter.
Given the strong correlation between people too lazy to walk to a chair, and people too lazy to throw away their trash, we had to provided a convenient receptacle for trash that would also follow the target individual.</p>
<p>On a technical level, our project consists of two robots, a chair and a trash can. Both of these robots have the same control scheme (differential drive with two bi-directional driven wheels and casters on the back). Additionally, both of these robots have a Raspberry Pi onboard to control them as well as an Intel Realsense depth camera for observing the environment.
To detect and follow people, we implement two methods --- Aruco marker detection via OpenCV, which is computationally cheaper than trying to detect a human, as well as human detection via MediaPipe. Both of these methods return the coordinates in 3D space of the target relative to the robot, and the robot can drive accordingly.
Additionally, the robots are able to communicate --- while this is not necessarily essential for simple following behavior, the robots are able to communicate the positions of targets they see to each other, potentially opening the door to more complicated coordination schemes in the future.</p>
<p>We help control ther robots via a script that runs locally on our computer, providing a heartbeat to ensure the robots only drive when we have the capacity to stop them. At any moment, we can choose to override their movement and supply our own velocity commands to either robot.
The robotic chair is also a fully functional chair, capable of supporting the full weight of a person sitting on the chair while being reasonably comfortable and ergonomic.</p>
<p><img src="images/duckling_follow.jpg" alt="Finalized chair"/></p>
<div style="position:relative;padding-top:56.25%"><iframe src="https://www.youtube.com/embed/c71_gnccJls" style="position:absolute;top:0;left:0;width:100%;height:100%" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen=""></iframe></div>
<h3>System diagram</h3>
<p><img src="images/system_diagram.png" alt="System diagram image"/></p>
<h3>Goals</h3>
<p>In our design process, we initially outlined a set of design goals, designed chiefly around the mechanical, electrical, and software components of the project.</p>
<p>Our initial goals, from the first review, were as follows:</p>
<p>Mechanical:</p>
<ul>
<li>Weld an aluminum frame for a chair.</li>
<li>Upholster chair for comfort and fit wide range of people.</li>
<li>Durable drivetrain that can withstand the weight of a range of different people sitting.</li>
<li>Make drivetrain back drivable.</li>
</ul>
<p>Electrical:</p>
<ul>
<li>Easily replaceable/serviceable components</li>
<li>No/Minimal visible wires</li>
<li>Integrated e-stops</li>
<li>Robot movements can be overridden by a human pushing it</li>
</ul>
<p>Software:</p>
<ul>
<li>Localization relative to the followed person</li>
<li>Communication of sensor data between two robots</li>
<li>Image processing to identify targets to follow</li>
<li>Teleop control modes and software overrides</li>
</ul>
<p>We also outlined a preliminary software architecture sketch for our project, appearing as follows:</p>
<p><img src="images/early_software_diagram.png" alt="early software diagram"/></p>
<p>By the end of the second review, we had not added or removed goals from our intial list, and had made progress towards our initial goals.</p>
<p>We never had to entirely re-scope our goals or change any drastically, and are currently at the following stage:</p>
<p>Mechanical:</p>
<ul>
<li>The aluminum frame is welded, supports weight, and works very well.</li>
<li>The chair has not been upholstered --- however, we did study which chairs had more pleasant/ergonomic designs, and designed the chair to have a pleasant recline and soft surfaces made of wood, which are (surprisingly) quite comfortable to sit in.</li>
<li>The drivetrain withstands all weight we&#x27;ve put on it --- it does not drive well with the weight of a person, but this was not within the design goal --- the robot simply needs to approach a person and let them sit stationarily.</li>
<li>The drivetrain is back drivable, and the chair can be pushed in any way when not spinning the motors.</li>
</ul>
<p>Electrical:</p>
<ul>
<li>The components are easily replaceable, with the electronic box of the chair swappable after removing four screws. The batteries are interchangeable as well.</li>
<li>Most wires are contained in the body of the chair and trash can, out of view, with connectors attaching sets of wires to the right pins. Future progress on this front would involve soldering the wires to the motor leads and routing the motor control wires through the aluminum frame.</li>
<li>The e-stop is mechanically integrated with the frame, yet is not currently wired up. In the future, we would want to spec a relay for the e-stop to control, in order to not risk running more than the rated 10A current through it.</li>
<li>The robot movement can be overridden by a human pushing it.</li>
</ul>
<p>Software:</p>
<ul>
<li>The robots successfully localize themselves relative to a followed person and drive to approach the person, both with Aruco markers or with human detection via MediaPipe.</li>
<li>The two robots communicate their camera data between each other via the shared <code>/pose_updates</code> topic.</li>
<li>We successfully implemented image processing identifying Aruco markers and humans via OpenCV and MediaPipe.</li>
<li>The robots can be independently controlled via keyboard input on a teleop controller script, stop upon a heartbeat from that script dropping out, and can be stopped almost immediately upon pressing SPACE.</li>
</ul>
<h3>Decisions + Tradeoffs</h3>
<p>Over the course of the project, we have laid out reasoning behind the design decisions we came to making over the course of the project.</p>
<h4>Having multiple robots</h4>
<p>While this theoretically adds extra cost and requires us deal with communication between robots, implementing this inter-robot communication was among our learning goals for the project, and we were able to find most of the expensive components for free.
Additionally, the simpler trash can design allowed for us to test our initial code as soon as possible, given that the metal chair frame was only drivable late in the project. Were we not able to test code on the trash can, integration would have been even more difficult.</p>
<h4>Using ROS2</h4>
<p>The downsides of using ROS2 are the fact that it is a fairly heavy middleware to use, is nontrivial to set up right, and is picky about Ubuntu versions. However, these cons were mitigated by the following:</p>
<p>ROS2 makes interprocess and inter-robot communication much easier than networking manually.</p>
<p>ROS2 is something both of us on software (Ben and Julian) are familiar with using.</p>
<p>ROS2 provides a very convenient library for handling frame transforms, tf2.</p>
<p>ROS2 Humble provides a Docker image that lets us use the same environment on our different Raspberry Pis.</p>
<p>For these reasons, we decided to go with ROS2.</p>
<h4>Not integrating encoders</h4>
<p>In the final chair, encoders are not currently present. While we purchased encoders and spent multiple hours configuring them, reading the data sheet, and trying to interface with them, the difficulty they offered was not worth the time commitment near the close of this project. In particular, we ran into the following issues:</p>
<ul>
<li>Our encoders have the same I2C address without a multiplexer, so we would need to purchase an I2C multiplexer in order to read encoder data using I2C. The alternative is using PWM.</li>
<li>RPi 5 does not supprot kernel level interrutps via the PiGPIO library, which makes reading PWM signals less accurate.</li>
<li>Configuring the encoders to output PWM is difficult, requiring one resister be desoldered from the board, a script flashed to the Arduino to configure it, and a script carefully used to burn this configuration to write-once memory that cannot be changed in order for the configuration to persist.</li>
<li>With the non-burned encoder, we were still encountering difficulty consistently reading from the encoders.</li>
<li>We had not yet designed a mount for the encoders on the chair, only for the trash can.</li>
</ul>
<h4>Not integrating LiDAR</h4>
<p>In the final chair, the LiDAR sensor is mounted, but is not run. While interfacing with the LiDAR is not difficult --- we did this by the second review date, visualizing the LiDAR scan from the sensor --- we did not end up with software logic that accounted for obstacles. We have no obstacle avoidance built into the chair and trash can, so the LiDAR data did not provide any useful input given the state of our code.</p>
<h4>Overall</h4>
<p>Overall, we&#x27;re content with the progress we&#x27;ve made so far on the chair. While there are avenues to explore with respect to integrating the sensors we weren&#x27;t able to integrate and adding support for more insteresting and complicated control modes, we are proud of having made two functional robots, one of which doubles as a chair, which are able to follow an Aruco marker or human fairly well.</p>
<div style="position:relative;padding-top:56.25%"><iframe src="https://www.youtube.com/embed/Kuj1wVJ1OWI" style="position:absolute;top:0;left:0;width:100%;height:100%" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen=""></iframe></div>
<p>Links to videos in case display doesn&#x27;t work:
<a href="https://youtu.be/c71_gnccJls">Video 1</a>
<a href="https://youtu.be/Kuj1wVJ1OWI">Video 2</a></p></section><section id="mechanical" class="card"><h2>Mechanical</h2><h4>Trashbot V1:</h4>
<p>In the intrest of giving our lovely code demons as much time to test on physical hardware as possible, we began the mechanical journey with a super simple bot:</p>
<p><img src="images/IMG_2746.JPEG" alt=""/></p>
<p>As you can see, this bot has little thought put into wire management, or electronics plaement.
All we needed from this was a testbed with the same fundamental architecture as the final trashbot, and the chair.
As you can see, this bot was so small that the battery didn&#x27;t even fit inside!
Instead, it was put on top.
This both decreased print times, and made swaping fuses easier, but was a big compromise for industrial design.
On top of all of this, there was no place to mount a trashcan, making it a pretty trash trashbot.
Despite all of this, it performed it&#x27;s one purpose perfectly:</p>
<p>Letting the code team get used to new hardware, and prove the basic mechanical architecture we would use for the rest of the project.</p>
<p>This also gave us a larger window of time to work on the chair and trashbot V2 without the code or electrical team breathing down our necks!
Here is an image of Trashbot V1&#x27;s final CAD:</p>
<p><img src="images/TrashbotV1_CAD.png" alt=""/></p>
<h4>Trashbot V2:</h4>
<p>Trashbot V2 was a complete do-over compared ot trashbot V1.
We had tons of feadback from the electrical and code teams to implement.
The bigest change was an increase in footprint.
This let us finaly put the batery and power distrobution board inside the robot, as well as fit some new H-bridge motor controllers.
It also allowed us to mount the Intel Realsense depth camera in the frame.
This ensured it was better protected and removing unsightly exposed cables.
Last but certainly not least, the increased footprint allowed Trashbot V2 to actually carry a trashcan!</p>
<p>While the increase in size of Trashbot V2 seems exclusively like an upgrade, it makes one thing much harder:</p>
<p>Manufacturing:</p>
<p>We still wanted to use a 3D printed frame for Trashbot V2, but because of the increase in footprint, the frame no longer fit on a prusa printer.
To remedy this, we split the frame into 4 pieces.
This creates a new problem though: How do you re-connect the pieces?</p>
<p>For this, we designed a plate that could be laser cut which we could then screw each piece into.
Then, in combination with a laser cut lid, we would have a strong chassis.
Here is what that final CAD looked like:</p>
<p><img src="images/TrashbotV2_full_CAD.png" alt=""/></p>
<p>As nice as this concept seems, the clock had other ideas.
In the intrest of moving onto fabricating the chair, we were forced to use a different method to join the chassis pieces.
Inspired by RC glider wing designs, we made use of the very large flat surface area of the bot frame to create a strong tape joint.
Now, I know how that sounds, but you&#x27;d be suprised with how strong this tape joint actualy is!</p>
<p><img src="images/TrashbotV2_top_view_real.png" alt=""/></p>
<p>As you can see, with the new chassis, we have much more room for wire management and electronics placement.
You may also notice that the wheels are enclosed now.
This ensured that the Trashbot maintains the high level of industrial design that is expected from trashcans.
They are also a fair bit smaller, which helps to slow down the robot and allowed more precise control.</p>
<h4>Chair Design:</h4>
<p>The chair design process started in parallel with Trashbot V2.
This helped ensure that both projects were able to move along as quick as possible.
To start out with, we created a bunch of different sketches for chair ideas:</p>
<p><img src="images/Chair_sketches1.png" alt=""/>
<img src="images/Chair_sketches2.png" alt=""/></p>
<p>Then, as a team, we decided on one design to move forwards with based on industrial design, manufacturability, and ease of assembly.
Then we made some more detailed sketches of that design from a couple different angles:</p>
<p><img src="images/Chair_sketch_final.png" alt=""/></p>
<p>With this design concept finalized, we moved onto CAD.
The CAD for the chair requires the use of some fun tools:</p>
<p>3D sketches, and weldments!</p>
<p>3D sketching is fundamentaly the same as its 2D counterpats, but with double the degrees of freedom.
We do need this added complexity though, as we need to be able to model each tube of the chair in 3D space.
All we need to do to go from a 3D sketch to a final model is the Solidworks Weldments tool!
This beautiful tool lets you use pre-defined &quot;weldment profiles&quot; to turn any sketch line into a fully modeled tube.
Once we have the initial tubes made in CAD, we can make use of the trim extend tool to make the tubes not clip together.</p>
<p>After all this, we end up with a final CAD model that looks like this:</p>
<p><img src="images/Chair_CAD.png" alt=""/></p>
<p>And with that, we can move onto fabrication!</p>
<h4>Chair Fabrication:</h4>
<p>The fabrication process for the chair began with making the frame:</p>
<p>First we made a cut list:</p>
<p><img src="images/78542965809__6B6E25D3-66FC-4EFB-A777-5FE0BB3E6129.JPEG" alt=""/></p>
<p>We don&#x27;t need anything fancy with this, as long as all the critical dimensions are clearly called out.
With this, we were able to use a horizontal band saw to cut all the pieces of tubing we would need for the chair.
This whole process took around 6 hours, and was completed over the course of 2 days.</p>
<p>Once we had all the tubes cut to length, the next step was prepping them for welding:</p>
<p>TIG welding is very sensitive to contamination, so our first step of weld prepping involves removing anythign that could cause contamination.
To start off, we cleaned all of the coolant from the band saw off the tubes.
This not only entails cleaning the outside of the tubes, but the inside too.
Since welding should melt all the way through the base metal for propper penetration, any contamination on the back side of the weld will get drawn into the weld pool.
Luckily for us, the coolant we use for the band saw is water based, and as such, washes off very easily.
After rinsing the coolant off, we used the belt sander to add a bevel to the ends off all the tubes.
This will promote better weld penetration, thus giving stronger welds.
Also, since we need to grind down some of the welds for the sake of industrial design, or fitup, the bevel prevents surface level welds that will completely dissapear when ground flush.
Then we rinse the tubes again, this time ensuring that any aluminum dust or abrasive grit in or around the tube gets washed off.
The last cleaning that we need to do in a sink is degreasing.
This removes any oils our hands may have deposited on the surface.</p>
<p>Now our aluminum is ready to weld right?</p>
<p>Nope! we still have to do a final wipe down with acetone, followed by the most cruicial step: pre-heating.
Since aluminum conducts heat so much faster than steel, welding with cold base material is very dificult.
The pieces become very hard to join, and the weld puddle lags behind your torch agressively.
This will result in a very frustrating experience that culminates in lumpy looking, shallow welds.
To avoid this, all we have to do is pre-heat!</p>
<p>How do we know what temperature to pre-heat too?</p>
<p>All you need is a Sharpie.
Thicker aluminum like what we are welding generaly requires a preheat between 300 and 400 degrees.
Sharpie ink begins to burn off at around 350 degrees F, which makes it perfect for this!
To preheat, all we do is apply a Sharpie line along both sides of the joint we are about to weld.
Then we heat up the area using a blow torch until the Sharpie begins to dissapear.</p>
<p>Now we are finaly ready to lay down some beads!</p>
<p>To start out with, we fixtured the tubes for the side of the chair base to the table.
We then did the whole pre-heat routine, followed by laying down the first welds.
Once the first set of welds were done on each joint, we unclamped the piece from the weld table, and finished up the rest of the joints that were previously inaccessible.</p>
<p>Once this was done, we arive at the image below:</p>
<p><img src="images/IMG_2819.JPEG" alt=""/></p>
<p>Then we weld the seat back for the chair.
This is also fixtured to the table like the sides, but is much less complicated, as there are no fancy angles.</p>
<p>At this stage, we need to start grinding down some of the welds.
As sad as this is, it is a necessary evil that we must endure.
The industrial design gods will be angry at us if we have to many exposed welds.
This also improves the fitment of all the tubes that connect both halves of the chair together.
After both sides have been ground down, we can move onto the next stage:</p>
<p>Connecting the sides together!</p>
<p><img src="images/IMG_2860.JPEG" alt=""/></p>
<p>The crucial part of this step is ensuring that everything remains square.
My strategy for this was making use of a handy 90 degree clamp as well as a bit of elbow grease to flex tubes into place.
Other than that, this part of the process is fundamentaly the same as the previous steps.
The only part that required wierder fixturing was the seat back, as it mounts at a wierd angle in order to conform to the wierd angles that humans form.</p>
<p>This leaves us with a finished frame!</p>
<p><img src="images/IMG_2870.JPEG" alt=""/></p>
<p>While this isn&#x27;t a very comfortable chair, or a fun robot yet, it is certainly quite strong!
It&#x27;s already able to withstand the weight of our entire team jumping on it!</p>
<p><img src="images/IMG_2868.JPEG" alt=""/></p>
<p>The last step before we have a complete chassis is welding on all the parts that turn this from a chair frame into a robot frame.
This includes motor mounts, side panels for the electronics compartment, tabs, tabs, and more tabs!</p>
<p><img src="images/4614C96E-88C2-4276-AD32-46FA83D43B99.JPEG" alt=""/></p>
<p>With all the tabs welded on, the chair chassis is complete!</p></section><section id="electrical" class="card"><h2>Electrical</h2><h4>Design Ideology</h4>
<p>The electrical system was designed with repeatability and scalability as its primary goals. This approach allowed for both our chair and our trash can robots to share, fundamentally, the same electronics, despite differences in mechanical structure and motor power requirements</p>
<h4>The Electronics: High Level Overview</h4>
<p>From a high level, our electrical systems can be understood through the energy/data flow diagram shown below:</p>
<p><img src="images/energy_flow.png" alt=""/></p>
<p>Both robots are fully powered off of a single standalone battery, with the trash can having a 12V 7Ah LiFePO4, and the chair having a 12V 5Ah sealed lead-acid battery.</p>
<p>Power from the battery is routed through a fuse box, which provides both overcurrent protection and a convenient distribution point for multiple components. From the fuse box, the 12 V rail directly supplies power to the motor controllers, while a DC–DC buck converter steps the voltage down from 12 V to 5 V to power the Raspberry Pi.</p>
<p>Then, the Raspberry Pi supplies 3.3V logic power to the magnetic encoders and the logic-side power inputs of the motor controllers via its GPIO headers. The Intel RealSense camera is powered directly from one of the Raspberry Pi’s USB ports, which also carries data.</p>
<p>In terms of data flow, the Raspberry Pi communicates wirelessly with an external laptop, which is responsible for high-level robot motion commands. The Raspberry Pi sends its pose data from AprilTags or person-recognition through mediapipe as well as the encoder feedback from the motors. Based on these inputs, it generates motor control signals that are sent to the motor controllers via GPIO pins. Speed is controlled using PWM signals, while motor direction is set using a digital HIGH/LOW control line.</p>
<h4>Electronics: Lower-Level Description</h4>
<p>Our electronics can be further inspected through our electrical diagram shown below:</p>
<p><img src="images/electrical_diagram.png" alt=""/></p>
<p>Power and ground from the battery are connected directly to the main input terminals on the fuse box. Individual fused outputs from the fuse box supply the motor controller and the DC–DC buck converter with power. It should be noted that our motor controller is connected with a 1A fuse on our trash can and a 35A fuse on our chair, due to the high power consumption of the differing motors. The buck converter, however, is protected by a 5A fuse in both systems.</p>
<p>Fuse values were selected based on motor datasheet specifications, with additional margin to accommodate the surge current that occurs during motor startup. The 5A fuse for the buck converter was determined by dividing the recommended power supply for the Raspberry Pi, 25W, by our 12V input voltage, to get a value of about 2A. However, the closest fuse value we had on hand was 5A, which we deemed acceptable as we had powered the Raspberry Pi off of a 65W external power supply.</p>
<p>The output of the buck converter is then routed through an emergency stop (e-stop) switch to provide an additional layer of safety, and then into the Raspberry Pi’s 5V power input. From the Raspberry Pi, the motor controllers and the magnetic encoders are powered through the 3.3V pins, and the Raspberry Pi’s GPIO connections provide and receive control signals to the motor controllers and from the magnetic encoders. In the wiring diagram, green wires represent digital HIGH/LOW signals used to control motor direction, while blue wires represent PWM signals used for speed control and encoder output.</p>
<p>The motors are connected directly to the motor controller outputs, with motor direction being reversed electrically by swapping motor polarity as commanded by the controller. Finally, the camera is connected to the Raspberry Pi via USB, which supplies both power and data connectivity.</p></section><section id="software" class="card"><h2>Software Section</h2><h1>Software Overview</h1>
<h2>Design Goals</h2>
<p>Our chief design goals for the project in terms of software were as follows:</p>
<ul>
<li>At least two robots (trash can and chair) operating independently and communicating</li>
<li>Computer vision that can recognize an April Tag or Aruco Marker and determine the pose offset of it relative to the camera</li>
<li>Computer vision that can recognize a human to follow</li>
<li>Control code for the motor drivers to make the robots follow a specific target</li>
<li>Software overrides and remote control of the robots from a separate computer</li>
</ul>
<p>Additionally, one of our more idealistic goals was to structure the code in a way to be extensible for future use. In essence, we aimed to avoid hard-coding our specific number of robots, IDs of followed markers, and follow target of the robots as much as possible. We also sought to make the environment similar across both robots for the sake of reliability and consistency when testing.</p>
<h2>Software Layout</h2>
<p>Our final software layout is as follows:</p>
<p><img src="images/uml.png" alt="img"/></p>
<p>All code running on the robots runs within the context of a ROS2 Humble ecosystem, as this was a middleware both of us writing the software were comfortable with. ROS2 is useful for both interprocess and inter-computer communication, and given we had two robots, abstracting communication between them via a middleware familiar to us was a useful choice.
We package this code within a ROS2 package, <code>chair_robot</code>, contained at <code>ros2_ws/src/chair_robot</code>. The package is built using the <code>ament_cmake</code> wrapper and can be built by the user by running <code>colcon build</code> in the <code>ros2_ws</code> directory.</p>
<p>The primary software architecture is described by the code in these files:</p>
<p><code>robot_state.py</code>: Defines the overall state machine that the robot runs. Every robot maintains a state throughout its lifetime, determining its behavior. The states are as follows:</p>
<ul>
<li>&quot;follow&quot;: Default following state for the robot. While in this state, it will attempt to drive towards a target by using PID control to reduce its linear and angular error from the setpoint, defined as a position a set distance in front of the follow target, and an angle pointing towards them.</li>
<li>&quot;hold&quot;: Autonomous state for when a robot is within a tolerable follow range of the target. The robot will remain still unless its distance from the target leaves a specific range, defined as a threshold offset from the follow distance.</li>
<li>&quot;search&quot;: Autonomous state for when a robot has lost its target. The robot holds still while actively looking for a new target. This triggers upon not receiving updates to the target pose for a specific length of time.</li>
<li>&quot;stop&quot;: Hard stop for the robot, which is not exited autonomously. Triggers upon software override for teleop mode, if the teleop controller passes a &#x27;stop&#x27; command or is driving a robot of different ID, as well as if the robot does not receive a heartbeat from the controller for over a second.</li>
<li>&quot;teleop&quot;: The robot is manually controlled by the controller, and yields its own main loop to instead receive velocity commands from the controller.</li>
</ul>
<p><code>pose_from_arcuo.py</code>: Implements code for detecting an Aruco Marker pose using OpenCV&#x27;s built in functionality. This class has one method, <code>process_frame()</code>, which is called by the robot state class that holds a reference to this <code>VideoProcess</code> class.</p>
<ul>
<li>The process frame method reads in a new frame from the camera stream, detects any Aruco markers, identifies their IDs, and broadcasts them via the <code>/pose_updates</code> topic.</li>
</ul>
<p><code>pose_from_vision.py</code>: Implements code for detecting a human via MediaPipe. This is implemented as a ROS2 node continually publishing to the <code>/pose_updates</code> topic, where the position of the human is estimated by taking the points MediaPipe identifies as defining the hip bone of the person, roughly estimating depth given average human hip length, and determining x/y position via the camera intrinsics and position on the frame. This currently does no recnogition of specific humans nor tracking to ensure the same human is consitently detected.</p>
<p><code>transform_helper.py</code>: Implements two classes for dealing with the tf2 transform library, <code>StaticTranformBroadcaster</code> and <code>FrameUpdater</code>.
<code>StaticTranformBroadcaster</code> is a Node initialized at the start of the code execution, which simply broadcasts all static transforms defining the scene. These are transforms relating Aruco Marker locations relative to robots and the target relative to the world frame (which moves with the target). Ideally, this would allow for us to encode offsets of different tags from the wheel center of different robots, or encode the offsets of the cameras as well, though we did not yet implement this.
<code>FrameUpdater</code> is a class contained by the state machine, taking a reference to the robot&#x27;s Node object in order to call <code>rclpy</code> methods. The frame updater knows its robot&#x27;s ID number and transform name, and deals with updating it relative to other transforms upon receiving a transform update.</p>
<p>We generated a few other Python scripts over the course of development, though these remain for individual debugging purposes and are not integrated into the final product:</p>
<p><code>encoder_test.py</code> was used to test the readings from the magnetic encoders, initially with the PiGPIO library and later with the lgpio library after discovering the Pi 5 does not support lgpio. As we did not electrically integrate our encoders with our chair due to time constraints, this script, which defines a node listening for encoder callbacks, is currently unused.</p>
<p><code>robot_state_can.py</code> was used to make quick changes to <code>robot_state</code> solely for the purpose of running on the trash can, before as many parameters were defined in the launch files.</p>
<h3>Containers</h3>
<p>For the sake of consistency (and lack of version conflicts) we run both of our robots in a Docker container set up identically between the computers. Specifically, we created a Dockerfile pulling from the ROS2 Humble Docker image that installs all additional packages we use inside the container. We also provide two scripts for convenience --- <code>build_container.sh</code>, which builds the Docker image, and <code>run_container.sh</code>, which runs the Docker container and ensures all necessary video devices and X server environment variables, like DISPLAY, are properly passed into the container.</p>
<p>By using these scripts, we can ensure the environment between our two robots is as similar as possible.</p>
<h3>Launch files</h3>
<p>ROS2 allows for multiple nodes to be launched with specific parameters by bundling them withing a launch file, so we use these to make running the code simpler.</p>
<p><code>robot0_chair.launch.py</code> launches the <code>robot_state</code> node configured for the chair robot, as well as the <code>StaticTransformBroadcaster</code>, and sets the chair up to follow the target (id = -1). This also hardcodes the value of the video device to use, 4, though we&#x27;d like to change this in the future.</p>
<p><code>robot0_trashcan.launch.py</code> launches the <code>robot_state</code> node configured for the trash can, as well as the <code>StaticTransformBroadcaster</code>. and sets the can up to follow the target.</p>
<p><code>robot0_mp_launch.py</code> is a modified version of the chair launch script that uses <code>pose_from_video</code> instead of <code>pose_from_aruco</code>, relying on MediaPipe detection of humans instead of Aruco tags.</p>
<p><code>robot1_launch.py</code> launches the <code>robot_state</code> node configured for the trash can as a follower --- i.e., a robot following the robot with id == 0. This also does not launch <code>StaticTranformBroadcaster</code>, assuming robot0 has already run this node.</p>
<p>Importantly, all the robots require a heartbeat to be continually published by a controller in order to drive. For the sake of safety, we don&#x27;t want the robots executing motor commands if we do not have a way to override control; thus, we build the heartbeat into the teleoperation controller.
To run this controller, first ensure the computer running the controller is on the same network on the robots, and ensure the ROS_DOMAIN_ID is set to the same value (default 99 for this project). Then, run <code>ros2 run chair_robot teleop_controller</code> to run the controller node.
In the controller, pressing SPACE will set each robot to <code>stop</code>. Similarly, pressing ENTER/RETURN will set each robot to <code>follow</code> (autonomous) mode, from which each can change to the other autonomous modes as normal.
When not in autonomous mode (stopped,) the user can specify a robot to control by pressing the key corresponding to its ID --- e.g., press &#x27;0&#x27; to control robot 0. When controlling a robot, W, A, S, and D move forward, left, backward, and right, respectively. J reduces the power to the motors in 5% increments, and K increases it.</p>
<p>If the script shuts down, all robots will enter <code>stop</code> state within one second. This duration can be adjusted in the robot_state mode.</p>
<h3>Tuning the performance</h3>
<p>PID control has been implemented --- the robots have a setpoint both for linear distance from the robot as well as angular distance, and follow a PID controller which governs both. However, we did not have the time to properly tune the coefficients for PID control, nor the other coefficients like <code>follow_distance</code>, and thus the driving and follow behavior of the robots is suboptimal.</p>
<p>To tune or adjust these parameters, they can be listed with <code>ros2 param list</code> and subsequently tuned.</p></section><section id="project-management" class="card"><h2>PM Section</h2><h1>Project Management</h1>
<h2>Budget</h2>
<p>In constructing this project, we were allotted a budget of $250 to spend on obtaining materials.
In addition to this provided budget, we made significant use of a number of physical components that we obtained for free, either due to these components coming from our own personal items we had on hand, or due to options to receive or borrow items from others.</p>
<iframe src="https://docs.google.com/spreadsheets/d/e/2PACX-1vT_sNQfoW_teaEt_NFqAWRjRmWpaYOzrQvU49fg0_ZSqlX29fgLRRe-pDQ4J4A1h30ysuDitkdMucUW/pubhtml?gid=0&amp;single=true&amp;widget=true&amp;headers=false" width="100%" height="500" style="border:0"></iframe>
<p>In case the embedded budget table doesn&#x27;t load properly, <a href="https://docs.google.com/spreadsheets/d/1g4QV0g-guVgx9l4J72WvOyQc4mPhQWHedzNR20VXbSM/edit?usp=sharing">here is the link to the budget directly</a></p>
<p>Notes:
&quot;Found in Robolab&quot; items were unused items salvaged from previous robotics projects, our use of which was cleared with the relevant professor.
&quot;Personal&quot; items were those that some of us already owned.
All &quot;Found in Robolab&quot; and &quot;Personal&quot; items are listed with their <em>estimated</em> costs, as we did not have to pay these costs, but the cost is theoretically integrated into our project.</p>
<h3>Budget Reflection</h3>
<p>Our team was able to make ample use of materials we already had and could salvage, with many of the more expensive components we used (computers and cameras) either from personal supplies or found. While this appears to make the total cost of our project significant (on the order of 1,000 dollars,) much of this cost was unnecessary were we choosing components from the ground up.
For instance, the Raspberry Pi 5 that we used actually impeded some of our progress, as the different hardware didn&#x27;t support hardware level interrupts via PiGPIO and required us to use a container for running our desired version of ROS2, and the Realsense cameras were overkill for this project --- we didn&#x27;t use their depth data nor their API/library, we simply grabbed the raw video frames when we wanted.</p></section><section id="frame-update" class="card"><h2>Appendix A --- Frame Update Logic</h2><h1>Appendix A --- Frame Update Logic</h1>
<p>We recorded our original ideation for how we implement frame updates, and why we publish all frame updates to a <code>/pose_updates</code> topic shared by all robots.
Some of this method introduced unnecessary complexity in implementing this project with only two robots and a target, but we outline it here as a sort of rationale for the overall approach --- the idea was to create a system that would be fairly consistent and not vulnerable to race conditions in events that would be more common with more robots looking at each other at the same time:</p>
<p>One significant design decision for the robot software was the implementation of the robot localization. Small changes in position are accounted for by encoders, but the drift in robot position is accounted for by each robot identifying each other robot (or identifying the target) visually via a marker, computing the relative pose difference between the two.</p>
<p>We describe frame transforms using the TF2 library in ROS. TF2 builds a tree describing the relative transformations between different frames, and it’s worth noting that loops in the graph of frames are not permitted given that they would overconstrain the transforms — i.e. T_a-&gt;c and T_a-&gt;b * T_b-&gt;c describe the same transformation, so both cannot exist as separate transforms. This lends itself to a problem — Each robot can calculate its relative transform to another robot, yet in the TF2 tree, each is simply defined off of a transform to the world frame. Thus, when robot A sees robot B and needs to update their transform T_a-&gt;b, there are two free variables in the resulting equation: T_a-&gt;w and T_b-&gt;w (where w is the world frame every robot is based off of.) We have two problems here — determinism (how do we know which transform should be updated?) and race conditions (what if two robots see each other at the same time?)</p>
<p>Regarding determinism, the choice of which transform to update (or whether to update both of them some amount) ends up shifting the physical location of the world frame in space. If we try to hold our other robot-&gt;world transforms constant, the other robots will also end up shifting in physical space to align with the world frame. This shifting is inevitable — we really don’t know which transform is more “correct” and so we accept there’s some error in the other robots that will result in them shifting. (If we cared about some fixed world coordinate in space, we’d do some sort of pose graph optimization to minimize the error in our robot poses for every pose correction and produce some meaningful pose adjustment given this; in this case, we don’t care about the physical location of the origin, we just want the shifting of it to be deterministic/consistent.) However, if we enforce some order of “trust” of our different robots, we can at least ensure this shifting is deterministic. The easiest way to do this is number our robots and always update the transformation relating the higher-numbered robot to the world. This way, robot0 is always linked to the world frame simply by odometry, robot1 can be adjusted relative to robot0, robot2 adjusted relative to robot0 and robot1, etc.</p>
<p>The other issue is race conditions — both robots see each other at the same time, and if each tries to update their relative transform at the same time, we can get corrections applied twice. Enforcing an order of trust mitigates this to some extent — without error, each robot would try to apply the same transformation between the same frames — but we still get the messiness of both writing to the same transformation and taking priority over each other at random. To fix this, we need each transformation to have only one owner, and consider either having a single node own every transformation or having each robot update only its own. As we want our system to function in as distributed a manner as possible, we let each robot own its own transform relative to the world.</p>
<p>We then must define a way for a lower-numbered robot to let a higher-numbered robot know to update its transform. Either we have every robot broadcast every relative transform to a topic listened to by all robots, and have robots react when a message instructs them to update their own transform, or we give each robot a separate publisher for each other higher-numbered robot to directly instruct it to update its pose. From a performance perspective, the direct communication method wins out in terms of bandwidth for large swarms, with the number of messages sent scaling linearly with the number of robots. However, while the broadcast method scales quadratically with the number of robots, it is also much nicer and neater to implement (one topic, one publisher + one subscriber per robot), and given our small number of robots and very small message size (header, rotation, translation) we chose to implement this method for communicating frame transforms.</p></section><!--$--><!--/$--></main><script src="/desk-on-demand/_next/static/chunks/5f8f53e7772f4262.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[39756,[\"/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js\"],\"default\"]\n3:I[37457,[\"/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js\"],\"default\"]\n4:I[47257,[\"/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js\"],\"ClientPageRoot\"]\n5:I[81694,[\"/desk-on-demand/_next/static/chunks/3ed5c16b8b4912f1.js\"],\"default\"]\n8:I[97367,[\"/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js\"],\"OutletBoundary\"]\n9:\"$Sreact.suspense\"\nb:I[97367,[\"/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js\"],\"ViewportBoundary\"]\nd:I[97367,[\"/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js\"],\"MetadataBoundary\"]\nf:I[68027,[\"/desk-on-demand/_next/static/chunks/4fd93823156e59e8.js\"],\"default\"]\n:HL[\"/desk-on-demand/_next/static/chunks/9e7b770538ff6f2d.css\",\"style\"]\n:HL[\"/desk-on-demand/_next/static/media/c50f3c9c65fbdb75-s.p.cb017eca.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/desk-on-demand/_next/static/chunks/879e74ca08e01695.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"57A_BHLQooNDOH8pzkRaP\",\"c\":[\"\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/desk-on-demand/_next/static/chunks/9e7b770538ff6f2d.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"title\",null,{\"children\":\"Desk On Demand\"}]}],[\"$\",\"body\",null,{\"className\":\"inconsolata_db231763-module__KRi-XW__className\",\"children\":[[\"$\",\"header\",null,{\"className\":\"navbar\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#\",\"className\":\"navbar-icon\",\"children\":[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"data-prefix\":\"fas\",\"data-icon\":\"chair\",\"className\":\"svg-inline--fa fa-chair \",\"role\":\"img\",\"viewBox\":\"0 0 448 512\",\"aria-hidden\":\"true\",\"children\":[\"$\",\"path\",null,{\"fill\":\"currentColor\",\"d\":\"M152 256l0-181.8c-24.5 20.5-40 51.4-40 85.8l0 96 40 0zm48 0l48 0 0-205.4c-7.7-1.7-15.8-2.6-24-2.6s-16.3 .9-24 2.6L200 256zM296 74.2l0 181.8 40 0 0-96c0-34.4-15.5-65.2-40-85.8zM32 256l32 0 0-96C64 71.6 135.6 0 224 0S384 71.6 384 160l0 96 32 0c17.7 0 32 14.3 32 32l0 64c0 17.7-14.3 32-32 32l0 96c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-96-256 0 0 96c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-96c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32z\"}]}]}],[\"$\",\"nav\",null,{\"className\":\"navbar-links\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#overview\",\"children\":\"Overview\"}],[\"$\",\"a\",null,{\"href\":\"#mechanical\",\"children\":\"Mechanical\"}],[\"$\",\"a\",null,{\"href\":\"#electrical\",\"children\":\"Electrical\"}],[\"$\",\"a\",null,{\"href\":\"#software\",\"children\":\"Software\"}],[\"$\",\"a\",null,{\"href\":\"#project-management\",\"children\":\"Project Management\"}]]}]]}],[\"$\",\"main\",null,{\"className\":\"container\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"$L4\",null,{\"Component\":\"$5\",\"serverProvidedParams\":{\"searchParams\":{},\"params\":{},\"promises\":[\"$@6\",\"$@7\"]}}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/desk-on-demand/_next/static/chunks/879e74ca08e01695.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/desk-on-demand/_next/static/chunks/3ed5c16b8b4912f1.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L8\",null,{\"children\":[\"$\",\"$9\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@a\"}]}]]}],{},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"$9\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Le\"}]}]}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"6:{}\n7:\"$0:f:0:1:1:children:0:props:children:0:props:serverProvidedParams:params\"\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"a:null\ne:[]\n"])</script></body></html>